# Supabase Migration Guidelines

## Overview
Database migrations are version-controlled changes to your database schema. Follow these guidelines to create safe, reversible, and maintainable migrations.

## Migration Principles

### Golden Rules
1. **Never modify existing migrations** - Create new migrations to fix issues
2. **Always test migrations** - Test both up and down migrations in dev environment
3. **Make migrations reversible** - Include rollback logic when possible
4. **Keep migrations focused** - One logical change per migration
5. **Migrations should be idempotent** - Safe to run multiple times

## Creating Migrations

### Using Supabase CLI
```bash
# Create a new migration
supabase migration new migration_name

# Apply migrations
supabase db push

# Reset database and reapply all migrations
supabase db reset
```

### Naming Conventions
Use descriptive names with timestamp prefix (auto-generated):
- `20240115123456_create_users_table.sql`
- `20240115124530_add_email_to_profiles.sql`
- `20240115130000_create_posts_rls_policies.sql`

Name format: `{timestamp}_{description}.sql`
- Use snake_case
- Be specific and descriptive
- Include action: create, add, update, drop, alter

## Migration Structure

### Basic Template
```sql
-- Migration: {description}
-- Created at: {timestamp}

-- Create new table
CREATE TABLE IF NOT EXISTS table_name (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add indexes
CREATE INDEX IF NOT EXISTS idx_table_column ON table_name(column);

-- Enable RLS
ALTER TABLE table_name ENABLE ROW LEVEL SECURITY;

-- Add comments
COMMENT ON TABLE table_name IS 'Description of table purpose';
```

## Common Migration Patterns

### Creating Tables
```sql
-- Create table with standard fields
CREATE TABLE IF NOT EXISTS products (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  description TEXT,
  price NUMERIC(10, 2) NOT NULL CHECK (price >= 0),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Add indexes
CREATE INDEX idx_products_user_id ON products(user_id);
CREATE INDEX idx_products_created_at ON products(created_at DESC);

-- Enable RLS
ALTER TABLE products ENABLE ROW LEVEL SECURITY;

-- Add trigger for updated_at
CREATE TRIGGER update_products_updated_at
  BEFORE UPDATE ON products
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

### Adding Columns
```sql
-- Add column with default value
ALTER TABLE users
ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'active';

-- Add column with constraint
ALTER TABLE posts
ADD COLUMN IF NOT EXISTS view_count INTEGER DEFAULT 0 CHECK (view_count >= 0);
```

### Modifying Columns
```sql
-- Change column type
ALTER TABLE users
ALTER COLUMN email TYPE VARCHAR(320);

-- Add NOT NULL constraint (ensure no NULL values exist first)
UPDATE users SET email = 'placeholder@example.com' WHERE email IS NULL;
ALTER TABLE users
ALTER COLUMN email SET NOT NULL;

-- Add default value
ALTER TABLE posts
ALTER COLUMN status SET DEFAULT 'draft';
```

### Creating Relationships
```sql
-- Add foreign key
ALTER TABLE posts
ADD CONSTRAINT fk_posts_user_id
FOREIGN KEY (user_id)
REFERENCES auth.users(id)
ON DELETE CASCADE;

-- Create junction table (many-to-many)
CREATE TABLE IF NOT EXISTS post_tags (
  post_id UUID REFERENCES posts(id) ON DELETE CASCADE,
  tag_id UUID REFERENCES tags(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (post_id, tag_id)
);
```

### Adding Indexes
```sql
-- Single column index
CREATE INDEX IF NOT EXISTS idx_posts_published_at
ON posts(published_at DESC);

-- Composite index
CREATE INDEX IF NOT EXISTS idx_posts_user_status
ON posts(user_id, status);

-- Partial index (conditional)
CREATE INDEX IF NOT EXISTS idx_posts_published
ON posts(published_at)
WHERE status = 'published';

-- Full-text search index
CREATE INDEX IF NOT EXISTS idx_posts_content_search
ON posts USING gin(to_tsvector('english', content));
```

### Creating Views
```sql
-- Create view for common queries
CREATE OR REPLACE VIEW user_post_stats AS
SELECT
  u.id AS user_id,
  u.email,
  COUNT(p.id) AS post_count,
  MAX(p.created_at) AS last_post_at
FROM auth.users u
LEFT JOIN posts p ON u.id = p.user_id
GROUP BY u.id, u.email;
```

### Creating Functions and Triggers
```sql
-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- Apply trigger to table
CREATE TRIGGER update_posts_updated_at
  BEFORE UPDATE ON posts
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

## Safety Checks

### Before Migration
- Backup production database
- Test migration in development environment
- Review SQL for syntax errors
- Check for breaking changes
- Verify rollback procedure

### During Migration
```sql
-- Use transactions for safety
BEGIN;

-- Your migration SQL here

-- Verify changes
SELECT * FROM information_schema.tables WHERE table_name = 'new_table';

-- Commit if everything looks good
COMMIT;

-- Or rollback if issues found
-- ROLLBACK;
```

### Data Migrations
```sql
-- Update existing data safely
BEGIN;

-- Create backup of data being modified
CREATE TEMP TABLE users_backup AS
SELECT * FROM users WHERE condition;

-- Perform update
UPDATE users
SET column = value
WHERE condition;

-- Verify update
SELECT COUNT(*) FROM users WHERE new_condition;

COMMIT;
```

## Destructive Operations

### Dropping Columns
```sql
-- Drop column (careful - data loss!)
-- Comment out for safety, uncomment when sure
-- ALTER TABLE users DROP COLUMN IF EXISTS old_column;
```

### Dropping Tables
```sql
-- Drop table (careful - data loss!)
-- DROP TABLE IF EXISTS old_table CASCADE;
```

### Renaming
```sql
-- Rename table
ALTER TABLE old_name RENAME TO new_name;

-- Rename column
ALTER TABLE users RENAME COLUMN old_column TO new_column;
```

## Supabase-Specific

### Auth Integration
```sql
-- Reference auth.users
ALTER TABLE profiles
ADD CONSTRAINT fk_profiles_user_id
FOREIGN KEY (user_id)
REFERENCES auth.users(id)
ON DELETE CASCADE;
```

### Storage Integration
```sql
-- Create storage bucket
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true);
```

### RLS Policies
```sql
-- Create RLS policy in migration
CREATE POLICY "Users can view own profile"
ON profiles
FOR SELECT
TO authenticated
USING (auth.uid() = user_id);
```

## Rollback Strategy

### Include Rollback Comments
```sql
-- Migration: Add email_verified column
-- Rollback: ALTER TABLE users DROP COLUMN email_verified;

ALTER TABLE users
ADD COLUMN IF NOT EXISTS email_verified BOOLEAN DEFAULT false;
```

## Testing Migrations

### Test Checklist
- [ ] Migration runs without errors
- [ ] Indexes are created successfully
- [ ] Foreign key constraints work correctly
- [ ] RLS policies function as expected
- [ ] Application code works with changes
- [ ] Performance is acceptable
- [ ] Rollback works if needed

### Validation Queries
```sql
-- Check table exists
SELECT EXISTS (
  SELECT FROM information_schema.tables
  WHERE table_schema = 'public'
  AND table_name = 'table_name'
);

-- Check column exists
SELECT column_name, data_type
FROM information_schema.columns
WHERE table_name = 'table_name';

-- Check indexes
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'table_name';
```

## Migration Anti-Patterns

### Avoid
- Modifying existing migrations after they've been applied
- Large data migrations in schema migrations (use separate data scripts)
- Dropping columns/tables without backup plan
- Missing indexes on foreign keys
- Forgetting to enable RLS on new tables
- Not testing migrations before production
- Mixing multiple unrelated changes in one migration
